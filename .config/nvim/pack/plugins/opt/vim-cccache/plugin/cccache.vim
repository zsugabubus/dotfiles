" USAGE:
"
" packadd vim-cccache
" if CCCacheBegin(expand('<sfile>'))
"   finish
" endif
" [Hi ...]...
" call CCCacheEnd()

function! CCCacheBegin(sfile) abort
	let s:colors_name = fnamemodify(a:sfile, ':t:r')
	let s:cache =
		\ (has('nvim') ? stdpath('cache') : '/tmp').
		\ '/'.s:colors_name.
		\ '-'.&background.
		\ (has('nvim') ? '-nvim' : '').
		\ '.vim'
	if getftime(a:sfile) <=# getftime(s:cache)
		execute 'source' fnameescape(s:cache)
		return 1
	endif

	let s:cached_cmds = [
	\  printf('" GENERATED BY cccache.vim FROM %s. DO NOT MODIFY.', a:sfile)
	\]

	" Cache Input... And... Output it.
	command! -nargs=* Ciao call add(s:cached_cmds, substitute(<q-args>, '\v([ !])  *', '\1', 'g'))|<args>
	command! -nargs=+ Hi call s:hi(<f-args>)

	Ciao hi clear
	execute "Ciao let colors_name='".s:colors_name."'"
	Ciao if exists("syntax_on")|syntax reset|endif

	return 0
endfunction

function! CCCacheEnd() abort
	try
		call writefile(s:cached_cmds, s:cache)
	catch
	endtry

	delcommand Hi
	delcommand Ciao
endfunction

function! s:hi(name, ...) abort
	let name = a:name
	if name[0] ==# '!'
		let name = name[1:]
		execute 'Ciao hi! clear' name
	elseif name[0] ==# '.'
		let name = name[1:]
		execute 'Ciao hi ' name 'NONE'
	endif
	if get(a:000, 0, '')[0] ==# '='
		execute 'Ciao hi! link ' name a:000[0][1:]
		return
	endif
	let cmd = 'Ciao hi '.name
	let attrs = {}
	for attr in a:000
		let [_, key, value; _] = matchlist(attr, '\v%(([a-z]+)\=)?(.*)')
		if !empty(key)
			" Choose value according to &background.
			let value = split(value, '\V|', 1)
			let value = get(value, len(value) ==# 2 && &background ==# 'dark', '')

			" Resolve highlight["." { attribute | name }].
			if value =~# '\m\C^[A-Z][a-z]'
				let [name, arg; _] = split(value, '\V.') + [key]
				redir => output
				silent! execute 'hi' name
				redir END
				let value = matchstr(output, ' '.arg.'=\zs[^ \n]*')
			endif

			if empty(value)
				continue
			endif

			let attrs[key] = value

			" Really. Fuck your diverging shit.
			if has('nvim') && key ==# 'cterm' && value =~# 'bold'
				let attrs['gui'] =
					\ get(attrs, 'gui', '').
					\ (!empty(get(attrs, 'gui', '')) ? ',' : '').value
			endif
		else
			let attrs[''] = value
		endif
	endfor

	let cmd = join([cmd] + map(
		\ filter(items(attrs), {_,kv-> !empty(kv[1])}),
		\ {_,kv->
		\   (!empty(kv[0]) ? kv[0].'=' : '').
		\   (type(kv[1]) ==# v:t_list ? join(kv[1], ',') : kv[1])
		\ }), ' ')
	execute cmd
endfunction
